# Scoring calibration for CQRS pattern v1
# This file contains the scoring rubrics used during code evaluation
# Pattern definition: patterns/application/cqrs/v1.yaml

pattern_ref:
  name: "CQRS (Command Query Responsibility Segregation)"
  version: "v1"

tactic_scoring:
  - tactic_id: "separate-command-query-directories"
    scoring_rubric:
      5: "Clear directory separation, all handlers in correct location"
      4: "Mostly separated, 1-2 handlers in wrong location"
      3: "Partial separation, inconsistent structure"
      2: "Handlers mixed together in single directory"
      1: "No separation, all in generic 'handlers' folder"
      0: "Not applicable"

  - tactic_id: "commands-return-id-only"
    scoring_rubric:
      5: "All command handlers return string (ID), void, or simple acknowledgment only"
      4: "One command returns slightly more than ID but still minimal"
      3: "Some commands return full objects or complex data"
      2: "Most commands return full data"
      1: "All commands return full objects, indistinguishable from queries"
      0: "Not applicable"

  - tactic_id: "queries-no-state-modification"
    scoring_rubric:
      5: "All query handlers purely read, zero state modifications"
      4: "Queries read-only except for negligible logging/metrics updates"
      3: "One query modifies non-critical state (e.g., last_accessed timestamp)"
      2: "Multiple queries modify state"
      1: "Queries frequently modify state, no separation from commands"
      0: "Not applicable"

  - tactic_id: "commands-orchestrate-domain"
    scoring_rubric:
      5: "Commands: load aggregate → call domain method → save via repository, no business logic in handler"
      4: "Commands follow pattern with minor business logic leakage"
      3: "Commands have significant business logic instead of delegating to domain"
      2: "Commands manipulate aggregates directly without using domain methods"
      1: "Commands bypass aggregates entirely, direct DB manipulation"
      0: "Not applicable"

  - tactic_id: "queries-return-dtos"
    scoring_rubric:
      5: "All queries return flat DTOs/response types, never domain aggregates"
      4: "Mostly DTOs, one query returns aggregate but it's read-only"
      3: "Mix of DTOs and aggregate returns"
      2: "Primarily returns aggregates"
      1: "Only returns domain aggregates, no DTO layer"
      0: "Not applicable"

  - tactic_id: "use-dependency-injection"
    scoring_rubric:
      5: "All handlers use @injectable with @inject for repositories, proper DI container registration"
      4: "Most handlers use DI correctly, 1 minor deviation"
      3: "Inconsistent DI usage, mix of injection and direct instantiation"
      2: "Primarily direct instantiation, minimal DI"
      1: "No DI, direct instantiation or singletons"
      0: "Not applicable"

  - tactic_id: "validate-inputs-in-handler"
    scoring_rubric:
      5: "Clear separation: handler validates inputs, domain validates business rules"
      4: "Good separation with minor overlap"
      3: "Some business validation in handler that should be in domain"
      2: "Most validation in handler, domain is anemic"
      1: "All validation in handler or no validation"
      0: "Not applicable"

  - tactic_id: "use-mapper-for-conversion"
    scoring_rubric:
      5: "All command handlers use dedicated mapper for API→domain conversion"
      4: "Mostly uses mappers, 1-2 inline conversions"
      3: "Mix of mappers and inline conversion logic"
      2: "Primarily inline conversion, no dedicated mappers"
      1: "No conversion, API types passed directly to domain"
      0: "Not applicable"

  - tactic_id: "queries-read-without-modifications"
    scoring_rubric:
      5: "All query handlers: read from repo → map to DTO → return, no aggregate methods called"
      4: "Mostly follows pattern, minor aggregate method calls for computed values"
      3: "Queries sometimes call aggregate business methods"
      2: "Queries frequently invoke aggregate business logic"
      1: "No distinction, queries and commands both invoke business methods"
      0: "Not applicable"

  - tactic_id: "name-command-handlers"
    scoring_rubric:
      5: "All command handlers follow *CommandHandler naming pattern"
      4: "Mostly follows pattern, 1 naming deviation"
      3: "Inconsistent naming across handlers"
      2: "Few handlers follow pattern"
      1: "No naming convention"
      0: "Not applicable"

  - tactic_id: "name-query-handlers"
    scoring_rubric:
      5: "All query handlers follow *QueryHandler naming pattern"
      4: "Mostly follows pattern, 1 naming deviation"
      3: "Inconsistent naming across handlers"
      2: "Few handlers follow pattern"
      1: "No naming convention"
      0: "Not applicable"

  - tactic_id: "structured-logging"
    scoring_rubric:
      5: "Comprehensive logging at entry/exit, includes correlation IDs and key data"
      4: "Good logging coverage with minor gaps"
      3: "Some logging but inconsistent"
      2: "Minimal logging, mostly debugging statements"
      1: "No logging or console.log only"
      0: "Not applicable"

  - tactic_id: "error-handling-boundary"
    scoring_rubric:
      5: "All handlers have error boundaries, proper error logging and transformation"
      4: "Most handlers have error handling, minor gaps"
      3: "Inconsistent error handling across handlers"
      2: "Minimal error handling, most errors unhandled"
      1: "No error handling, errors propagate raw"
      0: "Not applicable"
