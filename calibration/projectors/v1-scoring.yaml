# Scoring calibration for Projectors and Read Models pattern v1
# This file contains the scoring rubrics used during code evaluation
# Pattern definition: patterns/application/projectors/v1.yaml

pattern_ref:
  name: "Projectors and Read Models"
  version: "v1"

tactic_scoring:
  - tactic_id: "projector-per-aggregate"
    scoring_rubric:
      5: "Each aggregate has one projector, clear 1:1 mapping"
      4: "Mostly 1:1, one projector handles multiple unrelated aggregates"
      3: "Some aggregates share projectors inappropriately"
      2: "No clear aggregate-projector mapping"
      1: "Single projector handling all events"
      0: "Not applicable (no projectors)"

  - tactic_id: "handle-method-pattern"
    scoring_rubric:
      5: "All projectors implement handle(eventType, eventData) with switch statement"
      4: "Mostly follows pattern, one projector uses different approach"
      3: "Inconsistent handling patterns across projectors"
      2: "Few projectors use handle() pattern"
      1: "No consistent pattern for event handling"
      0: "Not applicable"

  - tactic_id: "use-ports-for-writing"
    scoring_rubric:
      5: "All projectors depend on port interfaces, no concrete dependencies"
      4: "One projector uses concrete implementation"
      3: "Multiple projectors bypass ports"
      2: "Most projectors use concrete implementations"
      1: "No port abstraction, direct infrastructure dependencies"
      0: "Not applicable"

  - tactic_id: "projectors-in-application"
    scoring_rubric:
      5: "All projectors in application/projectors/ directory"
      4: "One projector in wrong location"
      3: "Multiple projectors misplaced"
      2: "Projectors scattered across layers"
      1: "No organization, projectors anywhere"
      0: "Not applicable"

  - tactic_id: "injectable-projectors"
    scoring_rubric:
      5: "All projectors marked with @injectable()"
      4: "One projector missing decorator"
      3: "Multiple projectors not injectable"
      2: "Most projectors not using DI"
      1: "No dependency injection"
      0: "Not applicable (not using DI)"

  - tactic_id: "inject-dependencies"
    scoring_rubric:
      5: "All dependencies injected via constructor with @inject('PortName')"
      4: "One dependency not properly injected"
      3: "Some injected, some hardcoded"
      2: "Most dependencies hardcoded"
      1: "No injection, direct instantiation"
      0: "Not applicable"

  - tactic_id: "private-event-handlers"
    scoring_rubric:
      5: "Each event type has dedicated private handler method"
      4: "Mostly private handlers, one event inline"
      3: "Mix of private handlers and inline logic"
      2: "Primarily inline event handling"
      1: "All logic in switch statement, no methods"
      0: "Not applicable"

  - tactic_id: "structured-logging"
    scoring_rubric:
      5: "Comprehensive logging at entry/exit with event details and correlation"
      4: "Good logging with minor gaps"
      3: "Some logging but inconsistent"
      2: "Minimal logging"
      1: "No logging or only console.log"
      0: "Not applicable"

  - tactic_id: "denormalize-for-queries"
    scoring_rubric:
      5: "Read models optimized for queries, appropriate denormalization"
      4: "Mostly optimized, minor normalization overhead"
      3: "Some denormalization"
      2: "Primarily normalized, query inefficiencies"
      1: "No query optimization"
      0: "Not applicable (simple queries)"

  - tactic_id: "component-tests"
    scoring_rubric:
      5: "All projectors have component tests with DbTestHelper"
      4: "One projector missing component test"
      3: "Multiple projectors without component tests"
      2: "Most projectors lack component tests"
      1: "No component tests"
      0: "Not applicable (no projectors)"