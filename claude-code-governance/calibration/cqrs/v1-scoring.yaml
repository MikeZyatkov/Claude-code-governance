# Scoring calibration for CQRS pattern v1
# This file contains the scoring rubrics used during code evaluation
# Pattern definition: patterns/application/cqrs/v1.yaml

pattern_ref:
  name: "CQRS (Command Query Responsibility Segregation)"
  version: "v1"

tactic_scoring:
  - tactic_id: "separate-command-query-directories"
    scoring_rubric:
      5: "Clear directory separation, all handlers in correct location"
      4: "Mostly separated, 1-2 handlers in wrong location"
      3: "Partial separation, inconsistent structure"
      2: "Handlers mixed together in single directory"
      1: "No separation, all in generic 'handlers' folder"
      0: "Not applicable"

  - tactic_id: "commands-return-id-only"
    scoring_rubric:
      5: "All command handlers return string (ID), void, or simple acknowledgment only"
      4: "One command returns slightly more than ID but still minimal"
      3: "Some commands return full objects or complex data"
      2: "Most commands return full data"
      1: "All commands return full objects, indistinguishable from queries"
      0: "Not applicable"

  - tactic_id: "queries-no-state-modification"
    scoring_rubric:
      5: "All query handlers purely read, zero state modifications"
      4: "Queries read-only except for negligible logging/metrics updates"
      3: "One query modifies non-critical state (e.g., last_accessed timestamp)"
      2: "Multiple queries modify state"
      1: "Queries frequently modify state, no separation from commands"
      0: "Not applicable"

  - tactic_id: "commands-orchestrate-domain"
    scoring_rubric:
      5: "Commands: load aggregate → call domain method → save via repository, zero business logic in handler"
      4: "Commands follow pattern with only trivial formatting/conversion logic"
      3: "Commands have some business validation or domain rules (should be in aggregate)"
      2: "Commands have significant business logic, domain methods barely used"
      1: "Commands bypass aggregates entirely, direct DB manipulation or anemic domain"
      0: "Not applicable"

  - tactic_id: "queries-return-dtos"
    scoring_rubric:
      5: "All queries return flat DTOs/response types, never domain aggregates"
      4: "Mostly DTOs, one query returns aggregate but it's read-only"
      3: "Mix of DTOs and aggregate returns"
      2: "Primarily returns aggregates"
      1: "Only returns domain aggregates, no DTO layer"
      0: "Not applicable"

  - tactic_id: "use-dependency-injection"
    scoring_rubric:
      5: "All handlers use @injectable with @inject for repositories, proper DI container registration"
      4: "Most handlers use DI correctly, 1 minor deviation"
      3: "Inconsistent DI usage, mix of injection and direct instantiation"
      2: "Primarily direct instantiation, minimal DI"
      1: "No DI, direct instantiation or singletons"
      0: "Not applicable"

  - tactic_id: "validate-inputs-in-handler"
    scoring_rubric:
      5: "Perfect separation: handler validates technical inputs only, all business rules in domain"
      4: "Mostly correct with one minor business validation in handler"
      3: "Multiple business validations in handler that should be in domain"
      2: "Most business validation in handler, domain is anemic"
      1: "All business validation in handler or no validation"
      0: "Not applicable"

  - tactic_id: "use-mapper-for-conversion"
    scoring_rubric:
      5: "Mappers used for reused conversions, inline for single-use (follows Infrastructure pattern)"
      4: "Mostly follows pattern, one unnecessary mapper or missing reuse"
      3: "Inconsistent mapper usage"
      2: "Too many single-use mappers or missing needed mappers"
      1: "No conversion, API types passed directly to domain"
      0: "Not applicable"

  - tactic_id: "queries-read-without-modifications"
    scoring_rubric:
      5: "All query handlers: read from repo → map to DTO → return, no aggregate methods called"
      4: "Mostly follows pattern, minor aggregate method calls for computed values"
      3: "Queries sometimes call aggregate business methods"
      2: "Queries frequently invoke aggregate business logic"
      1: "No distinction, queries and commands both invoke business methods"
      0: "Not applicable"

  - tactic_id: "name-command-handlers"
    scoring_rubric:
      5: "All command handlers follow *CommandHandler naming pattern"
      4: "Mostly follows pattern, 1 naming deviation"
      3: "Inconsistent naming across handlers"
      2: "Few handlers follow pattern"
      1: "No naming convention"
      0: "Not applicable"

  - tactic_id: "name-query-handlers"
    scoring_rubric:
      5: "All query handlers follow *QueryHandler naming pattern"
      4: "Mostly follows pattern, 1 naming deviation"
      3: "Inconsistent naming across handlers"
      2: "Few handlers follow pattern"
      1: "No naming convention"
      0: "Not applicable"

  - tactic_id: "structured-logging"
    scoring_rubric:
      5: "Comprehensive logging at entry/exit, includes correlation IDs and key data"
      4: "Good logging coverage with minor gaps"
      3: "Some logging but inconsistent"
      2: "Minimal logging, mostly debugging statements"
      1: "No logging or console.log only"
      0: "Not applicable"

  - tactic_id: "error-handling-boundary"
    scoring_rubric:
      5: "All handlers have error boundaries, proper error logging and transformation"
      4: "Most handlers have error handling, minor gaps"
      3: "Inconsistent error handling across handlers"
      2: "Minimal error handling, most errors unhandled"
      1: "No error handling, errors propagate raw"
      0: "Not applicable"
