pattern_name: "DDD Aggregates and Entities"
version: "v1"
domain: "Domain-Driven Design"

goal: |
  Maintain consistency boundaries and enforce business invariants within a
  cluster of related domain objects. Ensure that state changes are atomic,
  trackable, and valid according to business rules. Prevent external code
  from bypassing invariants by directly manipulating internal entities.

guiding_policy: |
  Define clear aggregate boundaries where one object (Aggregate Root) acts
  as the consistency guardian. All modifications to objects inside the
  aggregate must go through the root, which validates invariants before
  applying changes. Use event sourcing to track state changes explicitly,
  ensuring auditability and enabling event-driven architectures.

tactics:
  - id: "extend-aggregate-root"
    name: "Extend AggregateRoot from es-aggregates for root entities"
    priority: critical
    description: "Aggregate roots must extend AggregateRoot base class to inherit event sourcing capabilities"

  - id: "define-entities-with-base-class"
    name: "Define entities within aggregate using Entity base class"
    priority: critical
    description: "Child entities (e.g., Contract, Occupancy) must extend Entity and receive applier function"

  - id: "encapsulate-state"
    name: "Encapsulate state with private fields and public getters"
    priority: critical
    description: "All internal state as private fields (prefix with _), expose via public getters only"

  - id: "static-factory-creation"
    name: "Implement static factory method for aggregate creation"
    priority: critical
    description: "Provide static create() method that validates and emits creation event"

  - id: "register-event-handlers"
    name: "Register event handlers in constructor"
    priority: critical
    description: "Use register() in constructor to map event types to state mutation handlers"

  - id: "apply-via-events"
    name: "Apply state changes via events using applyChange()"
    priority: critical
    description: "All state mutations must create domain event and call applyChange(), never mutate state directly"

  - id: "validate-before-events"
    name: "Validate business invariants before emitting events"
    priority: important
    description: "Check all business rules and throw DomainError before creating events"

  - id: "delegate-entity-creation"
    name: "Delegate entity creation to entity static factories"
    priority: important
    description: "When creating child entities, use Entity.create() which returns events"

  - id: "private-entity-collections"
    name: "Keep entity collections private with public getters returning readonly/copies"
    priority: important
    description: "Entity collections (Maps, Arrays) private, expose via getters returning Array.from() or readonly"

  - id: "aggregate-level-modifications"
    name: "Provide aggregate-level methods for all entity modifications"
    priority: important
    description: "Don't expose entities for external modification, provide aggregate methods instead"

  - id: "route-child-entity-events"
    name: "Route child entity events through entity.route() method"
    priority: optional
    description: "When entity events occur, call entity.route(event) to apply within entity boundary"

  - id: "use-map-for-collections"
    name: "Use Map for entity collections when lookup by ID is needed"
    priority: optional
    description: "Store entities in Map<string, Entity> for efficient ID-based retrieval"

constraints:
  - rule: "Aggregate root MUST be the only entry point for modifications"
    description: "External code cannot directly modify entities or value objects inside aggregate"
    exceptions: []
    evaluation: "llm_judge"

  - rule: "All state changes MUST produce domain events"
    description: "Every mutation must create and apply a domain event, no direct field assignment in business methods"
    exceptions:
      - "Event handlers registered in constructor can directly assign to private fields"
      - "Static factory() method for deserialization"
    evaluation: "llm_judge"

  - rule: "Entities MUST NOT have public setters"
    description: "No public methods that directly mutate state, all changes via aggregate root"
    exceptions: []
    evaluation: "deterministic"  # Can check via AST for public set methods

  - rule: "Aggregate boundaries MUST NOT overlap"
    description: "One entity belongs to exactly one aggregate, no shared entities"
    exceptions: []
    evaluation: "llm_judge"

  - rule: "Domain validation MUST throw DomainError on invariant violations"
    description: "Use DomainError (not generic Error) for business rule violations"
    exceptions:
      - "Infrastructure errors (DB, network) use appropriate error types"
    evaluation: "deterministic"  # Can grep for 'throw new Error' vs 'throw new DomainError'

  - rule: "Entity constructors MUST receive applier function"
    description: "Entities get applier: (e: IEvent) => void parameter to propagate events to root"
    exceptions:
      - "Aggregate root itself doesn't receive applier (it is the applier)"
    evaluation: "deterministic"  # Check constructor signatures

related_patterns:
  - "Event Sourcing"
  - "CQRS"
  - "Repository Pattern"

anti_patterns:
  - name: "Anemic Domain Model"
    description: "Aggregates/entities with only getters/setters and no business logic"
  - name: "God Aggregate"
    description: "Aggregate containing too many entities, making it hard to maintain consistency"
  - name: "Aggregate Boundary Violation"
    description: "Directly manipulating child entities from outside the aggregate"

references:
  - "Evans, Eric. Domain-Driven Design: Tackling Complexity in the Heart of Software"
  - "Vernon, Vaughn. Implementing Domain-Driven Design"
  - "es-aggregates library documentation"
